

Mustafa Eren DEMÄ°RCÄ°
A Survey of Software Techniques to Emulate Heterogeneous Memory Systems in
High-Performance Computing
-ClÃ©ment Foyer, Brice Goglin, AndrÃ©s Rubio ProaÃ±o

Ä°ÅŸlemcilerin artan hesaplama gÃ¼cÃ¼, bellek sistemlerinde Ã¶nemli deÄŸiÅŸiklikler yapÄ±lmasÄ± ihtiyacÄ± oluÅŸturmaktadÄ±r. 

Bu anlamda atÄ±lan ilk adÄ±m iÅŸlemci ile bellek arasÄ±na iÅŸlemci hÄ±zÄ±na daha yakÄ±n olan Ã¶nbelleklerin eklenmesidir.

Bu konuda yeni bir adÄ±m iÃ§in ise heterojen bellek sistemleri Ã¼zerinde Ã§alÄ±ÅŸÄ±lmaktadÄ±r.
BÃ¶lÃ¼m 1



Heterojen Bellek Sistemi
FarklÄ± tÃ¼rde belleklerin bir arada kullanÄ±ldÄ±ÄŸÄ± sistem yapÄ±sÄ±dÄ±r. 

Ã–rneÄŸin DRAM (Dynamic RAM),
HBM (High Bandwidth Memory), NVM (Non-Volatile Memory) gibi bellek yapÄ±larÄ±nÄ±n bir arada kullanÄ±ldÄ±ÄŸÄ± sistemlerdir.

Bu noktada temel amaÃ§ farklÄ± mimariye sahip bellek tÃ¼rlerinin avantajlÄ± yÃ¶nlerinden faydalanarak daha verimli bir sistem oluÅŸturmaktÄ±r.


Ã–rnek Bellek TÃ¼rleri




Heterojen bellek kullanÄ±mÄ±na ilk Ã¶rnek, 2016 yÄ±lÄ±nda piyasaya sÃ¼rÃ¼len Intel Knights Landing Xeon Phi(KNL) â€˜dir.  KNL, bÃ¼yÃ¼k kapasiteli NVMâ€™ler ve DRAM desteÄŸi sunmaktadÄ±r.

Bu Ã§ok Ã§ekirdekli iÅŸlemci, 400 GB/s bant geniÅŸliÄŸi sunan 16 GBâ€™lÄ±k gÃ¶mÃ¼lÃ¼ DRAM ile birlikte gelmekteydi.
Bu tablo, heterojen bellek mimarilerinin neden Ã¶nemli olduÄŸunu aÃ§Ä±kÃ§a gÃ¶stermekte.

Sistemin tasarÄ±mÄ±na gÃ¶re uygun bellek seÃ§ilmelidir.
Tek bir merkezi bellek havuzu bulunur.

TÃ¼m iÅŸlemciler belleÄŸe eÅŸit sÃ¼rede eriÅŸir.

Tek soketli sistemler, kiÅŸisel bilgisayarlar, dÃ¼ÅŸÃ¼k seviye gÃ¶mÃ¼lÃ¼ sistemler gibi yerlerde kullanÄ±lÄ±r.

UMA (Uniform Memory Access) 
NUMA (Non-Uniform Memory Access) 
vs.
Her iÅŸlemcinin yerel bellek alanÄ± bulunur.

Bellek eriÅŸim sÃ¼resi iÅŸlemciye gÃ¶re deÄŸiÅŸir. 

Ã‡ok soketli sunucular, HPC, bÃ¼yÃ¼k veri iÅŸleme, Render gibi iÅŸlemlerde kullanÄ±lÄ±r
Ä°ÅŸlemcilerin ortak bellek kullanÄ±mÄ±, yÃ¼ksek hÄ±zda iletim saÄŸlayabilen ara baÄŸlantÄ± ihtiyacÄ± da doÄŸurmuÅŸtur. Bu ihtiyaca yanÄ±t verebilen CXL teknolojisini inceleyelim.

CXL (Compute Express Link)
CXL, PCI Express (PCIe) altyapÄ±sÄ±nÄ± kullanan ama daha dÃ¼ÅŸÃ¼k gecikme ve daha esnek bellek paylaÅŸÄ±mÄ± sunan bir ara baÄŸlantÄ± teknolojisidir.

CXL sayesinde CPU ile GPU, FPGA gibi diÄŸer iÅŸlem birimleri aynÄ± belleÄŸi dÃ¼ÅŸÃ¼k gecikme ile paylaÅŸabilir.

CXL, Intel Ã¶ncÃ¼lÃ¼ÄŸÃ¼nde geliÅŸtirilse de ÅŸu anda CXL Consortium adÄ±yla AMD, NVIDIA, Microsoft, Google, Samsung, Meta, Alibaba gibi devler tarafÄ±ndan destekleniyor.

YakÄ±nda Ã§Ä±kacak Ã§oÄŸu CPU, farklÄ± tÃ¼rde bellek ve cihazlarÄ±n Ã¶nbellek uyumlu bir ÅŸekilde baÄŸlanmasÄ±na olanak tanÄ±yan yeni bellek ara baÄŸlantÄ± teknolojisi CXLâ€™i destekleyecektir.


Heterojen Bellek Sistemiâ€™nin YazÄ±lÄ±m Ãœzerindeki Etkisi
BÃ¶lÃ¼m 2



Bant geniÅŸliÄŸiyle sÄ±nÄ±rlÄ± iÅŸlem Ã§ekirdekleri, tampon belleklerini mÃ¼mkÃ¼nse HBM Ã¼zerinde konumlandÄ±rmalÄ±dÄ±r.

Gecikmeyle sÄ±nÄ±rlÄ± Ã§ekirdekler ise NVMâ€™lerden kaÃ§Ä±nmalÄ±dÄ±r. AyrÄ±ca DRAM gecikmesi HBMâ€™e benzediÄŸi iÃ§in DRAM tercih edilmeli ve HBM kapasitesini boÅŸa harcamamaya dikkat edilmelidir.

GÃ¼nÃ¼mÃ¼zdeki heterojen bellek platformlarÄ±, iyi bilinen performans Ã¶zelliklerine sahiptir. 

AÅŸaÄŸÄ±daki ÅŸemada gÃ¶sterildiÄŸi gibi, kapasite genellikle HBMâ€™den DRAMâ€™e, oradan da NVMâ€™lere doÄŸru artar.
9


Ancak, farklÄ± donanÄ±m yapÄ±larÄ±nÄ±n Ã§eÅŸitliliÄŸi nedeniyle bu stratejileri gelecekteki platformlara genellemek zordur.

Bu yÃ¼zden, HPC(High Performance Computing) sistemlerinin donanÄ±m yapÄ±landÄ±rmasÄ±nÄ± taÅŸÄ±nabilir bir ÅŸekilde tanÄ±mlayabilmesi gerekmektedir.
KNLâ€™in piyasaya sÃ¼rÃ¼lmesiyle birlikte memkind kÃ¼tÃ¼phanesi tanÄ±tÄ±lmÄ±ÅŸ ve DRAM ile HBM arasÄ±ndaki NUMA dÃ¼ÄŸÃ¼mlerini yazÄ±lÄ±msal olarak ayÄ±rt ederek bellek tahsislerini kolaylaÅŸtÄ±rmak amaÃ§lanmÄ±ÅŸtÄ±r.
Daha sonra, bu kÃ¼tÃ¼phane NVM desteÄŸi ile de geniÅŸletilmiÅŸtir.

memkind_hbw_malloc() gibi fonksiyonlarla spesifik tÃ¼rde bellek tahsisi yapabilir.

Sistemde hangi tÃ¼r belleklerin bulunduÄŸu yazÄ±lÄ±m dÃ¼zeyinde anlaÅŸÄ±lÄ±r hÃ¢le geldikten sonra, yazÄ±lÄ±mcÄ±larÄ±n bir sonraki adÄ±m olarak uygulamanÄ±n hangi veri kÃ¼melerinin hangi bellek tÃ¼rÃ¼ne elveriÅŸli olduÄŸunu belirlemesi gerekmektedir.

SÃ¼rekli ardÄ±ÅŸÄ±k veri okuyan iÅŸlemlerdeki veriler yÃ¼ksek bant geniÅŸliÄŸi isterken, belleÄŸe dÃ¼zensiz eriÅŸen algoritmalardaki veriler dÃ¼ÅŸÃ¼k gecikmeye ihtiyaÃ§ duyarlar.
Bu noktada veri kÃ¼mesi ile bellek tÃ¼rÃ¼ arasÄ±ndaki eÅŸleÅŸtirmenin yazÄ±lÄ±msal olarak yapÄ±lmasÄ±nÄ± saÄŸlayan 2 yÃ¶ntem bulunmaktadÄ±r.


Elde edilen veriler analiz edilerek hangi bellek dÃ¼ÄŸÃ¼mÃ¼ne hangi verilerin yerleÅŸtirilmesinin performans aÃ§Ä±sÄ±ndan uygun olacaÄŸÄ± belirlenir.


Bu araÃ§lar geliÅŸtiricilere kodlarÄ±nda heterojen belleÄŸi yÃ¶netme konusunda yardÄ±mcÄ± olsa da hÃ¢lÃ¢ yalnÄ±zca KNL ve XEON gibi birkaÃ§ platformda test ve uygulama imkanÄ± sunmakta.

Bu nedenle, farklÄ± bellek teknolojileri ve farklÄ± performanslara sahip platformlarÄ± taklit (emulate) edebilecek yÃ¶ntemlere ihtiyaÃ§ vardÄ±r.
UygulamalarÄ±n farklÄ± donanÄ±m bant geniÅŸliÄŸi ve gecikme seviyeleriyle test edilebileceÄŸi Performans Testi (Performance Emulation) ve uygulamalarÄ±n gerÃ§ekte Ã¶yle olmasa bile sanki heterojen bir bellek ortamÄ±ndaymÄ±ÅŸ gibi dÃ¼ÅŸÃ¼nÃ¼lmesini saÄŸlayarak test edilebileceÄŸi Ortam Testi (Environment Emulation) bulunmaktadÄ±r.





Performance Emulation
Yusuf Uzun

  Heterojen belleÄŸe uygun yazÄ±lÄ±m geliÅŸtirmek iÃ§in, hangi veri tamponlarÄ±nÄ±n gecikmeye ya da bant geniÅŸliÄŸine duyarlÄ± olduÄŸunu belirlemek gerekir.

Nedir?
Bu tespit; statik analiz, profil oluÅŸturma (profiling) ve kÄ±yaslama (benchmarking) 
yÃ¶ntemleriyle yapÄ±labilir.
KÄ±yaslama, en kolay yÃ¶ntemdir; ancak uygulamanÄ±n farklÄ± bellek yapÄ±larÄ±na sahip donanÄ±mlarda Ã§alÄ±ÅŸtÄ±rÄ±lmasÄ±nÄ± gerektirir.

Veri tamponlarÄ±nÄ±n hangi tÃ¼r performansa daha duyarlÄ± olduÄŸunu anlayabilmek iÃ§in Ã§eÅŸitli heterojen bellek yapÄ±larÄ±nÄ±n simÃ¼le edilmesine ihtiyaÃ§ duyulur.
Bu da farklÄ± bant geniÅŸliÄŸi ve gecikme koÅŸullarÄ±nÄ± yazÄ±lÄ±msal olarak taklit etmeyi gerektirir.

UygulamalarÄ± farklÄ± donanÄ±m yapÄ±larÄ±na gÃ¶re test etmek iÃ§in kullanÄ±lan donanÄ±m simÃ¼latÃ¶rleri, Ã¶zelleÅŸtirilebilir sanal platformlar sunar. 

Bu simÃ¼latÃ¶rlerde, CPU komutlarÄ± dÃ¶ngÃ¼ dÃ¼zeyinde Ã§alÄ±ÅŸtÄ±rÄ±lÄ±r ve bellek eriÅŸimleri Ã¶nbellekler Ã¼zerinden gerÃ§ekleÅŸtirilir. 

BÃ¶ylece uygulamanÄ±n performansÄ± gerÃ§ekÃ§i biÃ§imde tahmin edilebilir.
SimÃ¼latÃ¶rler
    SimÃ¼latÃ¶rler oldukÃ§a esnektir. FarklÄ± CPU sayÄ±larÄ±, bellek tÃ¼rleri, Ã¶nbellek yapÄ±larÄ± ve gecikme/bant geniÅŸliÄŸi deÄŸerleri tanÄ±mlanabilir. 

Ã–te yandan, CPU dÃ¶ngÃ¼leri yavaÅŸlatÄ±larak daha hÄ±zlÄ± bellek eriÅŸimleri simÃ¼le edilebilir. Ancak bu yÃ¶ntemin ciddi bir Ã§alÄ±ÅŸma zamanÄ± yÃ¼kÃ¼ vardÄ±r. 

Ã–rneÄŸin, SESC(SuperESCalar Simulator) simÃ¼latÃ¶rÃ¼ gerÃ§ek sistemden yÃ¼zlerce kat yavaÅŸ olabilir. Bu yavaÅŸlÄ±ÄŸÄ±n Ã§oÄŸu bellek alt sisteminin detaylÄ± simÃ¼lasyonundan kaynaklanÄ±r.


Ã–rneÄŸin:
EriÅŸimi yavaÅŸlatmak, eriÅŸim Ã¶ncesine gereksiz komutlar eklemek anlamÄ±na gelebilir.
EriÅŸimi hÄ±zlandÄ±rmak ise, Ã¶nceden getirme (prefetching) eklemek, eriÅŸimi tamamen kaldÄ±rmak ya da sabit bir adrese yÃ¶nlendirerek Ã¶nbelleÄŸe denk gelmesini saÄŸlamaktÄ±r.


2. Derleyici (Compiler) Teknikleri
DonanÄ±mÄ± simÃ¼le etmek yerine, uygulamanÄ±n bellek eriÅŸimlerini derleme ya da Ã§alÄ±ÅŸtÄ±rma aÅŸamasÄ±nda deÄŸiÅŸtirmek de mÃ¼mkÃ¼ndÃ¼r. 

Bu teknikle, eriÅŸimler yapay olarak yavaÅŸlatÄ±lÄ±p hÄ±zlandÄ±rÄ±larak farklÄ± bellek koÅŸullarÄ± taklit edilebilir.



3. NUMA Mesafesi
 NUMA (Non-Uniform Memory Access), heterojen bellek sistemlerini yazÄ±lÄ±msal olarak taklit etmekte kullanÄ±lan bir yÃ¶ntemdir. 

Ã‡Ã¼nkÃ¼ yerel bellek, sistemde fiziksel olarak daha uzakta yer alan belleklere gÃ¶re daha hÄ±zlÄ±dÄ±r.


NUMA HiyerarÅŸisi
Modern Ã§ok soketli sistemlerde iki ana seviyede NUMA yapÄ±sÄ± bulunur:
Soketler arasÄ±: Bir CPU, baÅŸka bir soketin belleÄŸine daha yavaÅŸ eriÅŸir.
 Soket iÃ§i: Bellek genellikle Ã§ekirdek gruplarÄ±na bÃ¶lÃ¼nÃ¼r. (Ã¶r. Intel SubNUMA, AMD Nodes per Socket).
Bu yÃ¼zden genellikle:
Yerel bellek, hÄ±zlÄ± bellek (HBM gibi)
Uzak bellek, yavaÅŸ bellek (NVDIMM gibi) olarak kabul edilir.


GeliÅŸmiÅŸ KullanÄ±m: SGI Altix Ã–rneÄŸi
BÃ¼yÃ¼k HPC sistemlerinde Ã§ok sayÄ±da CPU tek bir platformda birleÅŸtirilmiÅŸtir.

Blade'ler halka veya hiperkÃ¼p ÅŸeklinde aÄŸlarla (SGI NUMALink) birbirine baÄŸlanÄ±r.  Bu sayede Ã§ok farklÄ± NUMA mesafeleri oluÅŸturularak bant geniÅŸliÄŸi ve gecikme Ã¼zerinde bÃ¼yÃ¼k farklar elde edilebilir.

Ä°kili CPU gruplarÄ± "blade" olarak gruplanÄ±r.
 CPU ile bellek arasÄ±ndaki mesafe arttÄ±kÃ§a;
Bant geniÅŸliÄŸi dÃ¼ÅŸer,
Gecikme artar.
Bu yapÄ± Ã¶rnek bir heterojen bellek simÃ¼lasyonu olarak kullanÄ±labilir:
Yerel bellek: HBM (27 GB/s, 100 ns)
AynÄ± bladeâ€™deki diÄŸer CPUâ€™nun belleÄŸi: DRAM (10 GB/s, 450 ns)
Uzak bellek: NVDIMM (7 GB/s, 800 ns)


 Korsan uygulama, gerÃ§ek bir uygulamayÄ± yavaÅŸlatmak iÃ§in sistem kaynaklarÄ±nÄ± bilinÃ§li olarak tÃ¼keten ayrÄ± bir programdÄ±r. 

Ã–zellikle bellek bant geniÅŸliÄŸi veya Ã¶nbellek kapasitesi gibi kaynaklar hedef alÄ±nÄ±r. 

Bu yÃ¶ntem, daha yavaÅŸ bellek altyapÄ±sÄ±nÄ± taklit etmek amacÄ±yla kullanÄ±lÄ±r.
4. Korsan Uygulamalar (Resource Pirating)


ğŸ”§ NasÄ±l Ã‡alÄ±ÅŸÄ±r?

Ã–rneÄŸin bazÄ± Ã§ekirdeklerde STREAM dÃ¶ngÃ¼sÃ¼ Ã§alÄ±ÅŸtÄ±rÄ±lÄ±r (bellek bant geniÅŸliÄŸini tÃ¼ketmek iÃ§in).
AynÄ± CPU Ã¼zerindeki diÄŸer Ã§ekirdeklerde Ã§alÄ±ÅŸan uygulamanÄ±n performansÄ± ciddi ÅŸekilde dÃ¼ÅŸer.
KullanÄ±lan korsan Ã§ekirdek sayÄ±sÄ± arttÄ±kÃ§a performans dÃ¼ÅŸÃ¼ÅŸÃ¼ de artar.

Yandaki ÅŸekil bazÄ± Ã§ekirdeklerde STREAM dÃ¶ngÃ¼leri 
(bant geniÅŸliÄŸi odaklÄ±) Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±ÄŸÄ±nda, aynÄ± CPU paketi Ã¼zerindeki
 diÄŸer Ã§ekirdeklerde Ã§alÄ±ÅŸan uygulamalarÄ±n performansÄ±nÄ±n 
Ã¶nemli Ã¶lÃ§Ã¼de dÃ¼ÅŸtÃ¼ÄŸÃ¼nÃ¼ gÃ¶stermektedir. 

âš ï¸ DezavantajlarÄ±
Sadece bant geniÅŸliÄŸini deÄŸil, aynÄ± zamanda gecikmeye duyarlÄ± uygulamalarÄ± da etkiler.
Bu da â€œsadece gecikmeâ€ ya da â€œsadece bant geniÅŸliÄŸiâ€ Ã¼zerinde etkili bir senaryo oluÅŸturmayÄ± zorlaÅŸtÄ±rÄ±r.

KorsanÄ±n etkisi uygulamaya baÄŸlÄ±dÄ±r.
Uygulama belleÄŸi yoÄŸun kullanmÄ±yorsa korsan daha fazla kaynak Ã§alabilir.
Sabit bir etki yaratmak zordur.

GÃ¶zle gÃ¶rÃ¼lÃ¼r bir etki yaratmak iÃ§in Ã§ok sayÄ±da Ã§ekirdek gerekir.
Ã–rneÄŸin, 20 Ã§ekirdekli bir sistemde 4 korsan Ã§ekirdek yalnÄ±zca %20â€™lik bant geniÅŸliÄŸini Ã§alabilir.

5. Bant GeniÅŸliÄŸi KÄ±sÄ±tlama (Bandwidth Throttling)
      BazÄ± iÅŸlemciler, bellek bant geniÅŸliÄŸini sÄ±nÄ±rlandÄ±rarak farklÄ± performans seviyeleri oluÅŸturabilir. Bu yÃ¶ntem, heterojen bellek sistemlerini simÃ¼le etmek ve uygulamalarÄ±n bellek duyarlÄ±lÄ±ÄŸÄ±nÄ± test etmek iÃ§in kullanÄ±labilir.
ğŸŸ¢ AvantajlarÄ±
Ã–ngÃ¶rÃ¼lebilir ve sabit etki saÄŸlar.
Korsan iÅŸ parÃ§acÄ±ÄŸÄ±na gerek yoktur â†’ Ã§ekirdek kaybÄ± olmaz.
KullanÄ±cÄ± seviyesi yapÄ±landÄ±rma mÃ¼mkÃ¼ndÃ¼r; root eriÅŸimi yalnÄ±zca ilk kurulumda gerekir.
Ã‡alÄ±ÅŸma zamanÄ±nda deÄŸiÅŸtirilebilir.
âš ï¸ DezavantajlarÄ±
Ã‡oÄŸunlukla bant geniÅŸliÄŸi yerine frekans Ã¼zerinde Ã§alÄ±ÅŸÄ±r â†’ Gecikme de artabilir.
Genellikle root eriÅŸimi veya BIOSâ€™tan yeniden baÅŸlatma gerektirir.

6. Ã–nbellek Devre DÄ±ÅŸÄ± BÄ±rakma, BÃ¶lme ya da Kilitleme
Bellek performansÄ±nÄ± deÄŸiÅŸtirmek iÃ§in kullanÄ±lan yÃ¶ntemler, Ã¶nbellek davranÄ±ÅŸÄ±nÄ± manipÃ¼le etmeye dayanÄ±r. 
ÃœÃ§ temel yÃ¶ntem vardÄ±r:
Ã–nbellek Devre DÄ±ÅŸÄ± BÄ±rakma (Cache Disabling)
2.Ã–nbellek Kilitleme (Cache Locking / Pseudo-locking)
3.Ã–nbellek BÃ¶lme (Cache Partitioning)

Ã–nbellek Devre DÄ±ÅŸÄ± BÄ±rakma 
Ã–nbellek Kilitleme 
Ã–nbellek BÃ¶lme 
BazÄ± bellek bÃ¶lgeleri Ã¶nbelleÄŸe alÄ±namaz (uncachable) olarak iÅŸaretlenebilir.
Bu durum gecikmeyi artÄ±rÄ±r, bant geniÅŸliÄŸini azaltÄ±r â†’ bellek daha yavaÅŸ Ã§alÄ±ÅŸÄ±r.
Page Attribute Table (PAT) kullanÄ±larak sayfa bazÄ±nda uygulanÄ±r.
BazÄ± veri tamponlarÄ± her zaman Ã¶nbellekte tutulur.
BÃ¶ylece, sÃ¼rekli Ã¶nbellek isabeti (cache hit) saÄŸlanÄ±r.
SonuÃ§: Gecikme azalÄ±r, bant geniÅŸliÄŸi artar.
PaylaÅŸÄ±lan L3 Ã¶nbelleÄŸi birden fazla dilime bÃ¶lÃ¼nerek, her iÅŸlem grubuna belli bir Ã¶nbellek payÄ± ayrÄ±lÄ±r.
Daha az Ã¶nbellek â†’ Ã¶nbellek kaÃ§Ä±rma (miss) artar, bant geniÅŸliÄŸi dÃ¼ÅŸer, gecikme artar.


Performans Benzetiminin Ã–zeti
Performans benzetimi, bir uygulamanÄ±n farklÄ± bellek teknolojileri ve heterojen platformlarda nasÄ±l Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± incelemek iÃ§in bellek eriÅŸimlerinin performansÄ±nÄ± yapay olarak deÄŸiÅŸtirme yÃ¶ntemidir.
SimÃ¼latÃ¶r, en esnek yaklaÅŸÄ±m olsa da yavaÅŸlÄ±ÄŸÄ±, bÃ¼yÃ¼k uygulamalarÄ±n Ã§alÄ±ÅŸmasÄ±nÄ± incelemek aÃ§Ä±sÄ±ndan onu neredeyse kullanÄ±lamaz kÄ±lar.
Ã‡oÄŸu teknik, bellek eriÅŸimini hem gecikme (latency) hem de bant geniÅŸliÄŸi (bandwidth) aÃ§Ä±sÄ±ndan yavaÅŸlatabilir; ancak bu iki Ã¶zellik ayrÄ± ayrÄ± kontrol edilemez.
 â†’ Tabloâ€™daki â€œBant GeniÅŸliÄŸini Takip Ederâ€ ifadesi, gecikme ve bant geniÅŸliÄŸinin birbirinden baÄŸÄ±msÄ±z etkilenemediÄŸini belirtir.

Bellek Teknolojilerine GÃ¶re Ã–zet
HBM
GPU BelleÄŸi
Non-Volatile Memory (NVM)
CXL BelleÄŸi
Derleyici teknikleri ve Ã¶nbellek kilitleme ile kÄ±smen benzetilebilir. SimÃ¼latÃ¶rler tam benzetim saÄŸlar ama aÄŸÄ±rdÄ±r. Ã‡ok Ã§ekirdekli eriÅŸim simÃ¼latÃ¶rÃ¼ zorlaÅŸtÄ±rÄ±r.
YÃ¼ksek bant geniÅŸliÄŸi saÄŸlar, ancak CPU eriÅŸimi gecikmeli ve sÄ±nÄ±rlÄ±dÄ±r. En gerÃ§ekÃ§i yÃ¶ntem simÃ¼latÃ¶rdÃ¼r.
Daha dÃ¼ÅŸÃ¼k bant geniÅŸliÄŸi ve daha yÃ¼ksek gecikme, Ã§eÅŸitli tekniklerle kolayca benzetilebilir.
Yerel bellekten daha yavaÅŸ eriÅŸim sunar ve performansÄ±; cihaz, baÄŸlantÄ± ve topolojiye baÄŸlÄ±dÄ±r. Esnek benzetim teknikleri gerektirir.
Ã–zetle, performans benzetimi teknikleri farklÄ± avantaj ve kÄ±sÄ±tlamalara sahiptir. SeÃ§im, uygulamanÄ±n hedefi ve platform karmaÅŸÄ±klÄ±ÄŸÄ±na baÄŸlÄ±dÄ±r.




DinlediÄŸiniz Ä°Ã§in TeÅŸekkÃ¼rler


Bilal Ã–ztÃ¼rk
Environment Emulation
Environment Emulation (Ortam Taklidi) Nedir?
Environment Emulation, uygulama ya da Ã§alÄ±ÅŸma zamanÄ±nÄ±n, gerÃ§ekte Ã¶yle olmasa bile sanki heterojen bir bellek ortamÄ±ndaymÄ±ÅŸ gibi dÃ¼ÅŸÃ¼nmesini saÄŸlamaktÄ±r.
Fiziksel sistemde sadece DRAM olsa bile, uygulamaya HBM veya NVDIMM varmÄ±ÅŸ gibi gÃ¶sterilebilir.
BÃ¶ylece:
UygulamanÄ±n bu kaynaklarÄ± doÄŸru ÅŸekilde algÄ±layÄ±p algÄ±lamadÄ±ÄŸÄ± test edilebilir.
Uygulama davranÄ±ÅŸÄ± bu sahte ortamda analiz edilebilir.




Environment Emulation NasÄ±l GerÃ§ekleÅŸtirilir?



Environment Emulation YÃ¶ntemleri

Virtual Machines (Sanal Makineler)





Neden Sanal Makine?
Sanal makineler (Ã¶rneÄŸin QEMU/KVM) sadece birden Ã§ok sunucuyu tek bir fiziksel makinede Ã§alÄ±ÅŸtÄ±rmak iÃ§in deÄŸil, mevcut olmayan donanÄ±mÄ± taklit etmek iÃ§in de kullanÄ±lÄ±r.
Bu sayede:
GeliÅŸtiriciler gerÃ§ek donanÄ±m ellerine geÃ§meden Ã¶nce yazÄ±lÄ±m geliÅŸtirebilir.
Ã–rneÄŸin, daha piyasaya sÃ¼rÃ¼lmemiÅŸ olan CXL gibi yeni mimarileri test edebilirler.
Ä°ÅŸletim sistemi geliÅŸtiricileri, donanÄ±m henÃ¼z piyasada olmasa bile sÃ¼rÃ¼cÃ¼leri test edebilir.






Ã–rnek QEMU komut satÄ±rÄ±


Performans AÃ§Ä±sÄ±ndan Sanal Makineler

Sanal makineler genellikle fiziksel donanÄ±mlardan daha yavaÅŸtÄ±r. Ã–zellikle HPC uygulamalarÄ± iÃ§in bu durum Ã¶nemlidir Ã§Ã¼nkÃ¼ hesaplama, bellek eriÅŸimi, G/Ã‡ ve iletiÅŸim oranÄ±na baÄŸlÄ± olarak performans dÃ¼ÅŸer.

Ama burada asÄ±l hedef performans deÄŸil, uygulamanÄ±n doÄŸru davranÄ±p davranmadÄ±ÄŸÄ±nÄ± test etmektir.

Sanal makineler ÅŸu amaÃ§la kullanÄ±lÄ±r:
Uygulama gerÃ§ekten HBMâ€™yi tanÄ±yabiliyor mu?
DoÄŸru NUMA dÃ¼ÄŸÃ¼mÃ¼nÃ¼ bulup, performans hassas veri yapÄ±larÄ± iÃ§in orayÄ± mÄ± kullanÄ±yor?


QEMU gibi sanal makineler, heterojen bellek sistemlerini sahte olarak simÃ¼le etmek iÃ§in Ã§ok uygun bir araÃ§tÄ±r. Ã–zellikle:
DonanÄ±m daha piyasaya Ã§Ä±kmadan test yapÄ±labilir,
GeliÅŸtiriciler uygulamalarÄ±nÄ±n ortama adaptasyon yeteneÄŸini test edebilir, ancak gerÃ§ek performans Ã¶lÃ§Ã¼mÃ¼ iÃ§in fiziksel donanÄ±m gereklidir.


ACPI TablolarÄ±
(Advanced Configuration and Power Interface)






ACPI TablolarÄ± Nedir?
ACPI (Advanced Configuration and Power Interface) tablolarÄ±, iÅŸletim sistemine donanÄ±m topolojisini tanÄ±tan veri yapÄ±larÄ±dÄ±r.
Bu tablolar:
CPU Ã§ekirdeklerinin yerleÅŸimini,
Bellek bÃ¶lgelerini,
NUMA dÃ¼ÄŸÃ¼mlerini,
Bellek eriÅŸim mesafelerini (SLIT),
Bellek tÃ¼rlerini (DRAM, NVDIMM, HBM gibi) tanÄ±mlar.




ACPI TablolarÄ± Ãœzerinden Neler DeÄŸiÅŸtirilebilir?
Bellek boyutu,
Yerel konumu (locality),
EriÅŸim mesafesi (latency),
Performans Ã¶zellikleri,
Bellek tÃ¼rÃ¼ gibi Ã¶zellikler elle deÄŸiÅŸtirilebilir.
Bir CPUâ€™yu bir NUMA dÃ¼ÄŸÃ¼mÃ¼nden diÄŸerine taÅŸÄ±mak,
NUMA mesafe deÄŸerlerini (SLIT) deÄŸiÅŸtirmek,
Var olan bir NUMA dÃ¼ÄŸÃ¼mÃ¼nÃ¼ ikiye bÃ¶lmek:


Performans AÃ§Ä±sÄ±ndan ACPI TablolarÄ± 

Avantajlar
GerÃ§ek fiziksel makinada test imkanÄ±
DonanÄ±m davranÄ±ÅŸÄ± uygulamalara sahte olarak sunulabilir
TÃ¼m NUMA, HBM, NVDIMM gibi senaryolar taklit edilebilir



SÄ±nÄ±rlamalar
Toplam bellek miktarÄ± fiziksel sÄ±nÄ±ra baÄŸlÄ±
KarmaÅŸÄ±k yapÄ±landÄ±rma iÅŸlemleri gerekebilir
Firmware bilgisi ve araÃ§larÄ± gerekir




Ä°ÅŸletim Sistemi TarafÄ±ndan GÃ¶rÃ¼nen Fiziksel Bellek AralÄ±klarÄ±nÄ± DeÄŸiÅŸtirmek






AmaÃ§ Nedir?
Linux iÅŸletim sistemi tarafÄ±ndan gÃ¶rÃ¼len fiziksel bellek bÃ¶lgelerinin tÃ¼rÃ¼nÃ¼ ve kullanÄ±m ÅŸeklini deÄŸiÅŸtirmek, bÃ¶ylece farklÄ± bellek tÃ¼rleri (DRAM, NVDIMM, HBM gibi) varmÄ±ÅŸ gibi davranmasÄ±nÄ± saÄŸlamak.

Sistemdeki fiziksel bellek, sistem aÃ§Ä±lÄ±ÅŸÄ±nda iki kaynaktan iÅŸletim sistemine bildirilir:
E820 tablosu (eski BIOS sistemleri iÃ§in)
UEFI memory map (modern sistemler iÃ§in)
Bu tablolar belleÄŸin:
Nerede baÅŸladÄ±ÄŸÄ±nÄ±,
Ne kadar olduÄŸunu,
Ve ne tÃ¼rde olduÄŸunu belirtir.



Performans AÃ§Ä±sÄ±ndan Fiziksel Bellek AralÄ±klarÄ±nÄ± DeÄŸiÅŸtirmek 

Avantajlar
Kolay ve hÄ±zlÄ± ÅŸekilde uygulanabilir
GerÃ§ek donanÄ±m gerekmeden DAX/NVDIMM testleri yapÄ±labilir
UygulamanÄ±n belleÄŸe eriÅŸim davranÄ±ÅŸÄ± test edilebilir
SÄ±nÄ±rlamalar
NUMA dÃ¼ÄŸÃ¼mÃ¼ sayÄ±sÄ± deÄŸiÅŸtirilemez
GeliÅŸmiÅŸ topoloji esnekliÄŸi yok
GerÃ§ek performans simÃ¼lasyonu mÃ¼mkÃ¼n deÄŸil

Ã‡alÄ±ÅŸma ZamanÄ±nda (Runtime) DonanÄ±m GÃ¶rÃ¼nÃ¼mÃ¼nÃ¼ DeÄŸiÅŸtirme





NasÄ±l YapÄ±lÄ±r?
Ã‡oÄŸu HPC (High Performance Computing) uygulamasÄ± bellek yÃ¶netimi ve donanÄ±m topolojisi iÃ§in doÄŸrudan iÅŸletim sistemi ile etkileÅŸime girmez. Bunun yerine ara katman yazÄ±lÄ±mlarÄ±na gÃ¼venir:
Basit kÃ¼tÃ¼phaneler: libnuma
GeliÅŸmiÅŸ runtime kÃ¼tÃ¼phaneler: memkind, hwloc
Bu kÃ¼tÃ¼phaneler, iÅŸletim sisteminin sunduÄŸu donanÄ±m bilgilerini okuyarak (genellikle sysfs altÄ±ndaki yÃ¼zlerce dosyayÄ± tarayarak) NUMA dÃ¼ÄŸÃ¼mlerini, Ã§ekirdekleri, bellek yapÄ±larÄ±nÄ± vs. tanÄ±mlar.

Bu yÃ¼zden, eÄŸer bu kÃ¼tÃ¼phaneler kandÄ±rÄ±lÄ±rsa, uygulama da gerÃ§ekte var olmayan bir donanÄ±m yapÄ±sÄ±nÄ± gerÃ§ekmiÅŸ gibi gÃ¶rÃ¼r.




KullanÄ±lan AraÃ§lar
1. memkind
DRAM Ã¼zerindeki bazÄ± NUMA dÃ¼ÄŸÃ¼mlerini HBM gibi gÃ¶sterebilir.
GerÃ§ekte HBM olmayan sistemlerde, HBM-uyumlu uygulamalarÄ±n test edilmesine olanak saÄŸlar.
UygulamanÄ±n bant geniÅŸliÄŸi duyarlÄ± (bandwidth-sensitive) tamponlarÄ± bu sÃ¶zde-HBM alanlarÄ±nda oluÅŸturup oluÅŸturmadÄ±ÄŸÄ± test edilebilir.

2. hwloc
Ã‡ok daha gÃ¼Ã§lÃ¼ bir kÃ¼tÃ¼phane.
XML dosyasÄ± kullanarak, tamamen farklÄ± bir platform topolojisini simÃ¼le edebilir.
Bu XML topolojisi:
CPUâ€™larÄ±, Ã¶nbellek hiyerarÅŸisini, NUMA dÃ¼ÄŸÃ¼mlerini ve I/O birimlerini iÃ§erebilir.
hwloc kullanan her HPC uygulamasÄ±nda kullanÄ±labilir.
BÃ¶ylece geliÅŸtiriciler donanÄ±ma fiziksel olarak sahip olmasalar da, uygulamalarÄ±nÄ± farklÄ± donanÄ±m topolojileri Ã¼zerinde test edebilirler.


Environment Emulation BÃ¶lÃ¼m Ã–zeti
ve YÃ¶ntemlerin KarÅŸÄ±laÅŸtÄ±rÄ±lmasÄ±







YÃ¶ntemler ve AmaÃ§larÄ±




SonuÃ§
Environment emulation = DonanÄ±mÄ± deÄŸiÅŸtirmeden uygulamayÄ± kandÄ±rmak

Bu yÃ¶ntemlerle geliÅŸtirici:
â€œUygulama bu sahte HBM alanÄ±nÄ± doÄŸru tanÄ±yÄ±p kullanÄ±yor mu?â€ sorusuna yanÄ±t alÄ±r,
Ama â€œHBM kullandÄ±ÄŸÄ±nda ne kadar hÄ±zlandÄ±?â€ sorusuna yanÄ±t alamaz.


BÃ¶lÃ¼m 5 
SonuÃ§

Software Techniques to Emulate Heterogeneous Memory Systems in
High-Performance Computing




Ä°ki EmÃ¼lasyon ArasÄ±ndaki Fark


Genel Mesaj
Heterojen bellek sistemleri (Ã¶rneÄŸin HBM, DRAM, NVDIMM, CXL) exascale sistemlere giden yolda kaÃ§Ä±nÄ±lmaz hale geliyor.
FarklÄ± uygulamalarÄ±n ihtiyaÃ§larÄ± farklÄ±dÄ±r:
BazÄ± uygulamalar dÃ¼ÅŸÃ¼k gecikme sÃ¼resi (latency) ister,
BazÄ±larÄ± yÃ¼ksek bant geniÅŸliÄŸi (bandwidth),
DiÄŸerleri ise bÃ¼yÃ¼k kapasite (capacity) arar.
Bu yÃ¼zden bellek sistemlerinin tek tip olmaktan Ã§Ä±kmasÄ± gerekiyor.
Uygulama geliÅŸtiriciler, bu mimarilere uyum saÄŸlayacak ÅŸekilde kodlarÄ±nÄ± ÅŸimdiden hazÄ±rlamaya baÅŸlamalÄ±dÄ±r.

Performance Emulation (Performans EmÃ¼lasyonu)

AmaÃ§:
GerÃ§ek bir heterojen sistem olmadan, uygulamanÄ±n "performans davranÄ±ÅŸÄ±nÄ±" simÃ¼le etmek.
Environment Emulation (Ortam EmÃ¼lasyonu)

AmaÃ§:
Uygulamaya heterojen bir bellek ortamÄ± varmÄ±ÅŸ gibi bir gÃ¶rÃ¼nÃ¼m vermek (gerÃ§ekten olmasa bile).


DinlediÄŸiniz Ä°Ã§in TeÅŸekkÃ¼rler
Bilal Ã–ZTÃœRK

